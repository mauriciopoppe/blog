{{ $myList := slice "atari" "stripe" "triangles" }}
{{ $randomElement := index (shuffle $myList) 0 }}

{{ if .Get "type" }}
  {{ $randomElement = .Get "type" }}
{{ end }}

<div class="my-parallax tw-text-primary tw-absolute tw-left-0">
  <div class="tw-absolute tw-left-0 tw-top-0 tw-opacity-25">
    {{ if (eq $randomElement "atari") }}
      <style>
      css-doodle {
        --doodle-atary: (
          @grid: 1 / 100vw 100vh / #0a0c27;
          background-size: 200px 200px;
          background-image: @doodle(
            @grid: 6 / 100%;
            @size: 4px;
            font-size: 4px;
            color: hsl(@r240, 30%, 50%);
            box-shadow: @m3x5(
              calc(4em - @nx*1em) @ny(*1em)
                @p(@m3(currentColor), @m2(#0000)),
              calc(2em + @nx*1em) @ny(*1em)
                @lp
            );
          );
        );
      }
      </style>
      <css-doodle use="var(--doodle-atari)"></css-doodle>
    {{ end }}

    {{ if (eq $randomElement "stripe") }}
      <style>
      css-doodle {
        --doodle-stripe: (
          @grid: 10 / 100vw 100vh / #0a0c27;
          background: linear-gradient(
            @rand(360deg),
            @stripe(#F8B501, #60569e, #e6437d)
          );
        );
      }
      </style>
      <css-doodle use="var(--doodle-stripe)"></css-doodle>
    {{ end }}

    {{ if (eq $randomElement "triangles") }}
      <style>
      css-doodle {
        --doodle-triangles: (
          :doodle {
            @grid: 15x15;
            width: 100vw;
            height: 100vh;
            contain: layout;
          }
          /* generic gradient from https://mycolor.space/?hex=%23C27083&sub=1 */
          background: @pick(
            rgb(var(--primary)), #a3688a, #806289, #5e5b7f, #41536e
          );
          opacity: @rand(.9);
          transform:
            rotate(@rand(360deg))
            scale(@rand(4));
          clip-path: polygon(
            @rand(100%) 0,
            100% @rand(100%),
            0 @rand(100%),
            0 @rand(100%)
          );
        );
      }
      </style>
      <css-doodle use="var(--doodle-triangles)"></css-doodle>
    {{ end }}

    {{ if (eq $randomElement "ripple") }}
      <style>
      css-doodle {
        --doodle-ripple: (
          :doodle {
            @grid: 10;
            @size: 100vw 100vh;
            filter: @svg-filter(<svg>
              <filter>
                <feTurbulence type="fractalNoise" baseFrequency=".02" numOctaves="1" />
                <feDisplacementMap in="SourceGraphic" scale="300" />
              </filter>
            </svg>);
          }
          :container {
            animation: r 500s linear infinite;
          }
          @place: center;
          @size: 100% 2vmin;
          background: @pick-d(
            color-mix(in srgb, rgb(var(--primary)) 50%, black),
            color-mix(in srgb, rgb(var(--primary)) 70%, black),
            color-mix(in srgb, rgb(var(--primary)) 90%, black)
          );
          transform-origin: 5vmin center;
          transform:
            translateX(50%)
            rotate(calc(@i() * 360deg / @size()));

          @keyframes r {
            to { transform: rotate(1turn) }
          }
        );
      }
      </style>
      <css-doodle use="var(--doodle-ripple)"></css-doodle>
    {{ end }}
  </div>
  {{ .Inner }}
</div>
<div style="height: 100vh;"></div>

{{ if (eq $randomElement "ripple") }}
<div class="tw-text-center tw-mt-10">
  <a target="_blank" href="https://yuanchuan.dev/">Animation by Chuan</a>
</div>
{{ end }}

<script>
(function () {
  let parallaxTarget = '{{ .Get "parallaxTarget" }}'
  if (!parallaxTarget) {
    return
  }

  const myScrollableContent = document.querySelector(parallaxTarget);
  if (!myScrollableContent) {
    console.error(`could not find target=${parallaxTarget} to enable parallax.`)
    return;
  }

  myScrollableContent.style.position = "relative"
  myScrollableContent.style.top = `200px`

  const container = myScrollableContent.closest('.my-parallax');
  // The animation will be 20% faster than the scroll amount.
  const parallaxFactor = 1.2;

  function animateOnScroll() {
    const rect = container.getBoundingClientRect();
    const viewportHeight = window.innerHeight;

    // Start the animation 100px before the container enters the viewport.
    const animationStart = viewportHeight + 100;
    // Finish the animation as soon as the container leaves the viewport.
    const animationEnd = -container.offsetHeight;

    let translateY;
    if (rect.top > animationStart) {
      // Before animation starts, position is unchanged.
      translateY = 0;
    } else if (rect.top < animationEnd) {
      // After animation ends, lock to final position.
      const totalScroll = animationStart - animationEnd;
      translateY = -totalScroll * (parallaxFactor - 1);
    } else {
      // During animation, calculate position based on scroll.
      const scrollAmount = animationStart - rect.top;
      translateY = -scrollAmount * (parallaxFactor - 1);
    }

    myScrollableContent.style.transform = `translateY(${translateY}px)`;
  }

  let ticking = false;
  window.addEventListener('scroll', function() {
    if (!ticking) {
      window.requestAnimationFrame(function() {
        animateOnScroll();
        ticking = false;
      });
      ticking = true;
    }
  }, { passive: true });

  // Also run the animation on load.
  animateOnScroll();
})();
</script>

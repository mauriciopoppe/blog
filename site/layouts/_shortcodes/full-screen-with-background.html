{{ $myList := slice "atari" "stripe" "triangles" }}
{{ $randomElement := index (shuffle $myList) 0 }}

{{ if .Get "type" }}
  {{ $randomElement = .Get "type" }}
{{ end }}

<style>
  css-doodle {
    overflow: visible
  }
</style>

<div class="my-parallax tw-text-primary tw-absolute tw-left-0">
  <div class="tw-absolute tw-left-0 tw-top-0 tw-opacity-25">
    {{ if (eq $randomElement "atari") }}
      <css-doodle>
        @grid: 1 / 100vw 100vh / #0a0c27;
        background-size: 200px 200px;
        background-image: @doodle(
          @grid: 6 / 100%;
          @size: 4px;
          font-size: 4px;
          color: hsl(@r240, 30%, 50%);
          box-shadow: @m3x5(
            calc(4em - @nx*1em) @ny(*1em)
              @p(@m3(currentColor), @m2(#0000)),
            calc(2em + @nx*1em) @ny(*1em)
              @lp
          );
        );
      </css-doodle>
    {{ end }}

    {{ if (eq $randomElement "stripe") }}
      <css-doodle>
        @grid: 10 / 100vw 100vh / #0a0c27;
        background: linear-gradient(
          @rand(360deg),
          @stripe(#F8B501, #60569e, #e6437d)
        );
      </css-doodle>
    {{ end }}

    {{ if (eq $randomElement "triangles") }}
      <style>
      css-doodle {
        --doodle-triangles: (
          :doodle {
            @grid: 10x10;
            width: 100vw;
            height: 100vh;
            grid-gap: 3px;
            contain: layout;
          }
          background: @pick(rgb(--primary), #fe874e, #ff93cc);
          opacity: @rand(.9);
          transform:
            rotate(@rand(360deg))
            scale(@rand(4));
          clip-path: polygon(
            @rand(100%) 0,
            100% @rand(100%),
            0 @rand(100%),
            0 @rand(100%)
          );
        );
      }
      </style>
      <css-doodle use="var(--doodle-triangles)"></css-doodle>
    {{ end }}

    {{ if (eq $randomElement "ripple") }}
      <style>
      :root {
        --doodle-ripple-filter: (
          filter: @svg-filter(<svg>
            <filter>
              <feTurbulence type="fractalNoise" baseFrequency=".02" numOctaves="1" />
              <feDisplacementMap in="SourceGraphic" scale="300" />
            </filter>
          </svg>);
        );
      }
      </style>
      <css-doodle>
        :doodle {
          @grid: 10;
          @size: 100vw 100vh;
          @use: var(--doodle-ripple-filter);
        }
        :container {
          animation: r 500s linear infinite;
        }
        @place: center;
        @size: 100% 2vmin;
        background: @pick-d(
          color-mix(in srgb, rgb(var(--primary)) 50%, black),
          color-mix(in srgb, rgb(var(--primary)) 70%, black),
          color-mix(in srgb, rgb(var(--primary)) 90%, black)
        );
        transform-origin: 5vmin center;
        transform:
          translateX(50%)
          rotate(calc(@i() * 360deg / @size()));

        @keyframes r {
          to { transform: rotate(1turn) }
        }
      </css-doodle>
    {{ end }}
  </div>
  {{ .Inner }}
</div>
<div style="height: 100vh;"></div>

{{ if (eq $randomElement "ripple") }}
<div class="tw-text-center tw-mt-10">
  <a target="_blank" href="https://yuanchuan.dev/">Animation by Chuan</a>
</div>
{{ end }}

<script>
(function () {
  let parallaxTarget = '{{ .Get "parallaxTarget" }}'
  if (!parallaxTarget) {
    return
  }

  const myScrollableContent = document.querySelector(parallaxTarget);
  if (!myScrollableContent) {
    console.error(`could not find target=${parallaxTarget} to enable parallax.`)
    return;
  }

  myScrollableContent.style.position = "relative"
  myScrollableContent.style.top = `200px`

  const container = myScrollableContent.closest('.my-parallax');
  // The animation will be 20% faster than the scroll amount.
  const parallaxFactor = 1.2;

  function animateOnScroll() {
    const rect = container.getBoundingClientRect();
    const viewportHeight = window.innerHeight;

    // Start the animation 100px before the container enters the viewport.
    const animationStart = viewportHeight + 100;
    // Finish the animation as soon as the container leaves the viewport.
    const animationEnd = -container.offsetHeight;

    let translateY;
    if (rect.top > animationStart) {
      // Before animation starts, position is unchanged.
      translateY = 0;
    } else if (rect.top < animationEnd) {
      // After animation ends, lock to final position.
      const totalScroll = animationStart - animationEnd;
      translateY = -totalScroll * (parallaxFactor - 1);
    } else {
      // During animation, calculate position based on scroll.
      const scrollAmount = animationStart - rect.top;
      translateY = -scrollAmount * (parallaxFactor - 1);
    }

    myScrollableContent.style.transform = `translateY(${translateY}px)`;
  }

  let ticking = false;
  window.addEventListener('scroll', function() {
    if (!ticking) {
      window.requestAnimationFrame(function() {
        animateOnScroll();
        ticking = false;
      });
      ticking = true;
    }
  }, { passive: true });

  // Also run the animation on load.
  animateOnScroll();
})();
</script>
